# CLAUDE.md - Tech Challenge Fase 3

## üéØ ESTRAT√âGIA DE IMPLEMENTA√á√ÉO INCREMENTAL

### Abordagem de Deploy Progressivo
Este projeto ser√° implementado em **8 etapas incrementais** com valida√ß√£o obrigat√≥ria entre cada fase:

1. **Deploy Progressivo**: Cada etapa gera apenas os artefatos necess√°rios
2. **Valida√ß√£o Obrigat√≥ria**: Scripts de teste espec√≠ficos para cada componente
3. **Crit√©rios de Sucesso**: Checklist claro antes de prosseguir
4. **Rollback Granular**: Possibilidade de voltar atr√°s em qualquer ponto

### Como Usar Este Documento
- **Para gerar uma etapa**: Solicite "Gerar artefatos da ETAPA X"
- **Para validar**: Execute os comandos de deploy fornecidos
- **Para marcar como conclu√≠da**: Diga "ETAPA X conclu√≠da com sucesso"
- **Para atualizar**: Claude Code atualizar√° automaticamente o status

### INSTRU√á√ïES ESPECIAIS PARA CLAUDE CODE
```
PADR√ïES DE CODIFICA√á√ÉO:
- Todas classes, m√©todos, coment√°rios e testes em PORTUGU√äS
- Evitar coment√°rios desnecess√°rios (changelog vai no git)
- Manter apenas documenta√ß√£o t√©cnica essencial (contratos, arquitetura)
- Seguir padr√£o do pacote br.com.lanchonete.autoatendimento
- NUNCA usar System.out.println - sempre usar logs estruturados
- Exemplo de log: logger.info("Produto criado com ID: {}", produto.getId())

GEST√ÉO DE COMMITS:
- Ao finalizar grupo de artefatos relacionados, sugerir mensagem de commit
- Mensagem deve ser UMA FRASE concisa descrevendo o que foi implementado
- Agrupar artefatos logicamente (ex: todos TFs de uma etapa juntos)
- Usu√°rio copiar√°/editar√° a mensagem conforme necess√°rio
- Quando usu√°rio confirmar "commit feito", atualizar log do CLAUDE.md

AUTOMA√á√ÉO DE STATUS:
- Monitore "ETAPA X conclu√≠da" para atualizar [ ] TODO ‚Üí [ ] DONE
- Mantenha log das mudan√ßas no final do documento
- Preserve estrutura e formata√ß√£o original
```

### Status de Implementa√ß√£o
```
üìÖ CRONOGRAMA DE ETAPAS

üèóÔ∏è ETAPA 1: RDS + Lambda Connectivity Test   [ ] TODO / [ ] DOING / [X] DONE
‚ö° ETAPA 2: Lambda de Autentica√ß√£o Completa   [ ] TODO / [ ] DOING / [X] DONE  
üåê ETAPA 3: API Gateway + JWT Authorizer     [ ] TODO / [ ] DOING / [X] DONE
‚ò∏Ô∏è ETAPA 4: EKS Cluster                      [ ] TODO / [ ] DOING / [X] DONE
üì¶ ETAPA 5: Aplica√ß√µes Migradas              [ ] TODO / [ ] DOING / [X] DONE
‚ò∏Ô∏è ETAPA 6: Deploy Kubernetes                [ ] TODO / [ ] DOING / [ ] DONE
üîó ETAPA 7: Integra√ß√£o API Gateway ‚Üî EKS    [ ] TODO / [ ] DOING / [ ] DONE
üöÄ ETAPA 8: CI/CD + Finaliza√ß√£o             [ ] TODO / [ ] DOING / [ ] DONE
```

**COMANDO PARA ATUALIZA√á√ÉO AUTOM√ÅTICA**:
- "ETAPA 1 conclu√≠da" ‚Üí Claude Code marca ETAPA 1 como DONE
- "ETAPA 2 finalizada com sucesso" ‚Üí Claude Code marca ETAPA 2 como DONE
- "Terminei a ETAPA 3" ‚Üí Claude Code marca ETAPA 3 como DONE

---

## üìã PLANO DETALHADO DAS ETAPAS

### üèóÔ∏è ETAPA 1: RDS + Lambda Connectivity Test
**Dura√ß√£o**: 4-5 horas | **Status**: [ ] TODO

**Objetivo**: Infraestrutura RDS MySQL funcionando + Lambda conseguindo conectar

**Estrat√©gia**: Resolver problemas de conectividade VPC/Security Groups primeiro com Lambda simples

**Artefatos**:
- terraform/shared/ (variables, data sources, academy config)  
- terraform/database/ (RDS, security groups, migrations)
- lambda-connectivity-test/ (Lambda simples s√≥ para testar conex√£o)
- scripts/setup-aws-academy.sh
- scripts/validate-database-connectivity.sh

**Deploy**: 
```bash
./scripts/setup-aws-academy.sh
cd terraform/database && terraform apply -var-file="../shared/academy.tfvars"
./scripts/validate-database-connectivity.sh
```

**Crit√©rios de Sucesso**: 
- RDS rodando privadamente (n√£o p√∫blico)
- Lambda consegue conectar via VPC
- Schema criado + seeds inseridos
- Logs da Lambda confirmando conectividade
- Security Groups permitindo comunica√ß√£o Lambda ‚Üî RDS

**Sinaliza√ß√£o para Claude Code**: "ETAPA 1 conclu√≠da"

---

### ‚ö° ETAPA 2: Lambda de Autentica√ß√£o Completa
**Dura√ß√£o**: 3-4 horas | **Status**: [ ] TODO

**Objetivo**: Lambda de autentica√ß√£o (CPF + an√¥nimo) funcionando completamente

**Estrat√©gia**: Reutilizar configura√ß√µes de VPC/SG da etapa 1, implementar l√≥gica de auth

**Artefatos**:
- lambda-auth/ completo (AuthHandler, services, models, testes)
- Reutiliza√ß√£o das configura√ß√µes de rede da ETAPA 1
- pom.xml + template.yml
- scripts/test-lambda-auth.sh
- scripts/validate-lambda.sh

**Deploy**:
```bash
cd lambda-auth && mvn clean package
sam build && sam deploy --guided  
./scripts/test-lambda-auth.sh
./scripts/validate-lambda.sh
```

**Crit√©rios de Sucesso**: 
- Lambda deployed com l√≥gica completa
- Auth CPF funcionando (busca no RDS)
- Auth an√¥nimo funcionando (sess√£o tempor√°ria)
- JWT gerado corretamente
- Conectividade RDS j√° resolvida da etapa anterior

**Sinaliza√ß√£o para Claude Code**: "ETAPA 2 conclu√≠da"

---

### üåê ETAPA 3: API Gateway + JWT Authorizer
**Dura√ß√£o**: 3-4 horas | **Status**: [ ] TODO  

**Objetivo**: API Gateway com autentica√ß√£o funcionando

**Artefatos**:
- terraform/lambda/ (API Gateway, routes, JWT authorizer)
- JwtAuthorizerHandler.java
- scripts/test-api-gateway.sh  
- scripts/validate-auth-flow.sh

**Deploy**:
```bash
cd terraform/lambda && terraform apply -var-file="../shared/academy.tfvars"
./scripts/test-api-gateway.sh
./scripts/validate-auth-flow.sh
```

**Crit√©rios de Sucesso**: API Gateway operacional + JWT Authorizer + /auth p√∫blico + routes protegidas

**Sinaliza√ß√£o para Claude Code**: "ETAPA 3 conclu√≠da"

---

### ‚ò∏Ô∏è ETAPA 4: EKS Cluster
**Dura√ß√£o**: 2-3 horas | **Status**: [ ] TODO

**Objetivo**: Cluster EKS pronto para aplica√ß√µes

**Artefatos**:
- terraform/kubernetes/ (EKS, VPC Link, ALB)
- scripts/configure-kubectl.sh
- scripts/test-eks-connectivity.sh
- scripts/validate-cluster.sh

**Deploy**:
```bash
cd terraform/kubernetes && terraform apply -var-file="../shared/academy.tfvars"
./scripts/configure-kubectl.sh
./scripts/test-eks-connectivity.sh
./scripts/validate-cluster.sh
```

**Crit√©rios de Sucesso**: EKS ativo + nodes prontos + kubectl funcionando + VPC Link criado

**Sinaliza√ß√£o para Claude Code**: "ETAPA 4 conclu√≠da"

---

### üì¶ ETAPA 5: Aplica√ß√µes Migradas
**Dura√ß√£o**: 3-4 horas | **Status**: [ ] TODO

**Objetivo**: Apps da Fase 2 adaptadas para API Gateway context injection

**Artefatos**:
- applications/ (autoatendimento + pagamento adaptados)
- ApiGatewayContextFilter.java
- application-kubernetes.yml adaptado
- scripts/build-images.sh
- scripts/validate-apps.sh

**Deploy**:
```bash
./scripts/build-images.sh
./scripts/push-to-ecr.sh  
./scripts/validate-apps.sh
```

**Crit√©rios de Sucesso**: C√≥digo migrado + context filter + images buildadas + ECR push

**Sinaliza√ß√£o para Claude Code**: "ETAPA 5 conclu√≠da"

---

### ‚ò∏Ô∏è ETAPA 6: Deploy Kubernetes  
**Dura√ß√£o**: 2-3 horas | **Status**: [ ] TODO

**Objetivo**: Aplica√ß√µes rodando no EKS

**Artefatos**:
- k8s-manifests/ completo (deployments, services, HPA, ingress)
- scripts/deploy-k8s.sh
- scripts/validate-k8s-apps.sh

**Deploy**:
```bash
./scripts/deploy-k8s.sh
kubectl wait --for=condition=ready pod -l app=autoatendimento --timeout=300s
./scripts/validate-k8s-apps.sh
```

**Crit√©rios de Sucesso**: Pods rodando + services OK + ALB configurado + HPA ativo

**Sinaliza√ß√£o para Claude Code**: "ETAPA 6 conclu√≠da"

---

### üîó ETAPA 7: Integra√ß√£o API Gateway ‚Üî EKS
**Dura√ß√£o**: 2-3 horas | **Status**: [ ] TODO

**Objetivo**: API Gateway roteando para EKS com context injection

**Artefatos**:
- terraform/lambda/api-gateway-routes.tf (routes para EKS)
- scripts/test-end-to-end.sh
- scripts/test-context-injection.sh  
- scripts/validate-integration.sh

**Deploy**:
```bash
cd terraform/lambda && terraform apply -var-file="../shared/academy.tfvars"
./scripts/test-end-to-end.sh
./scripts/validate-integration.sh
```

**Crit√©rios de Sucesso**: API Gateway ‚Üí EKS funcionando + context injection + autentica√ß√£o end-to-end

**Sinaliza√ß√£o para Claude Code**: "ETAPA 7 conclu√≠da"

---

### üöÄ ETAPA 8: CI/CD + Finaliza√ß√£o
**Dura√ß√£o**: 3-4 horas | **Status**: [ ] TODO

**Objetivo**: GitHub Actions + documenta√ß√£o + v√≠deo

**Artefatos**:
- .github/workflows/ completo
- docs/ completo  
- README.md final
- VIDEO.md
- scripts/test-complete-flow.sh

**Deploy**:
```bash
git add .github/workflows/ && git commit && git push
./scripts/test-complete-flow.sh
./scripts/prepare-video.sh
```

**Crit√©rios de Sucesso**: Workflows funcionando + PRs fechados + teste end-to-end + ambiente para v√≠deo

**Sinaliza√ß√£o para Claude Code**: "ETAPA 8 conclu√≠da"

---

## üìã VIS√ÉO GERAL DO PROJETO

### Contexto
- **Projeto**: Migra√ß√£o do sistema de lanchonete da Fase 2 para arquitetura cloud-native
- **Plataforma**: AWS Academy (usando LabRole)
- **Estrutura**: Monorepo com separa√ß√£o por contextos
- **Teste**: Via cURL (sem frontend)
- **Entrega**: Reposit√≥rio privado + v√≠deo demonstrativo

### Objetivos T√©cnicos
1. **API Gateway** como ponto de entrada √∫nico
2. **Lambda de autentica√ß√£o** (CPF + an√¥nimo) sem Cognito
3. **EKS** para aplica√ß√µes existentes
4. **RDS MySQL** gerenciado
5. **CI/CD** completo com GitHub Actions
6. **Terraform** para toda infraestrutura
7. **JWT** para autentica√ß√£o stateless

## üèóÔ∏è ARQUITETURA T√âCNICA

### Fluxo de Requisi√ß√µes
```
üì± Cliente (cURL) 
   ‚Üì POST /auth {cpf: "123"}
üåê API Gateway 
   ‚Üì AWS_PROXY
‚ö° Lambda Auth (Java)
   ‚Üì buscarPorCpf()
üóÑÔ∏è RDS MySQL
   ‚Üì JWT gerado
üé´ Token retornado
   ‚Üì Authorization: Bearer jwt
üåê API Gateway + JWT Authorizer
   ‚Üì Headers injetados (X-Cliente-ID, X-Auth-Type)
üì° VPC Link ‚Üí ALB
   ‚Üì 
‚ò∏Ô∏è EKS Pods
   ‚Üì
üóÑÔ∏è RDS MySQL
```

### Componentes AWS
- **API Gateway**: Controle de acesso, roteamento, JWT authorizer
- **Lambda**: Autentica√ß√£o (Java 17, Spring Boot)
- **EKS**: Cluster Kubernetes para aplica√ß√µes
- **RDS**: MySQL 8.0 gerenciado
- **VPC Link**: Comunica√ß√£o privada API Gateway ‚Üí EKS
- **ALB**: Application Load Balancer interno
- **ECR**: Registry para imagens Docker

## üìÇ ESTRUTURA DO MONOREPO

```
lanchonete-tech-challenge-fase3/
‚îú‚îÄ‚îÄ .github/workflows/              # CI/CD GitHub Actions
‚îÇ   ‚îú‚îÄ‚îÄ deploy-lambda.yml          # Deploy Lambda + API Gateway
‚îÇ   ‚îú‚îÄ‚îÄ deploy-infra-k8s.yml       # Deploy EKS + VPC Link
‚îÇ   ‚îú‚îÄ‚îÄ deploy-infra-db.yml        # Deploy RDS
‚îÇ   ‚îú‚îÄ‚îÄ deploy-applications.yml     # Deploy apps para EKS
‚îÇ   ‚îî‚îÄ‚îÄ cleanup.yml                # Limpeza de recursos
‚îú‚îÄ‚îÄ terraform/                     # Infraestrutura como c√≥digo
‚îÇ   ‚îú‚îÄ‚îÄ lambda/                    # API Gateway + Lambda
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tf               # Provider, data sources
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lambda.tf             # Lambda function
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api-gateway.tf        # API Gateway + routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authorizer.tf         # JWT Authorizer
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ variables.tf          # Vari√°veis
‚îÇ   ‚îú‚îÄ‚îÄ database/                 # RDS MySQL
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tf               # Provider, data sources
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rds.tf                # RDS instance
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ security-groups.tf    # Security groups
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ variables.tf          # Vari√°veis
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ migrations/           # Scripts SQL
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ 001_create_schema.sql
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ 002_seed_data.sql
‚îÇ   ‚îú‚îÄ‚îÄ kubernetes/               # EKS + Networking
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tf               # Provider, data sources
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ eks.tf                # EKS cluster + node groups
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vpc-link.tf           # VPC Link para API Gateway
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ alb.tf                # Application Load Balancer
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ variables.tf          # Vari√°veis
‚îÇ   ‚îî‚îÄ‚îÄ shared/                   # Recursos compartilhados
‚îÇ       ‚îú‚îÄ‚îÄ variables.tf          # Vari√°veis globais
‚îÇ       ‚îî‚îÄ‚îÄ academy.tfvars        # Valores para AWS Academy
‚îú‚îÄ‚îÄ lambda-auth/                  # Fun√ß√£o de autentica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ src/main/java/br/com/lanchonete/auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AuthHandler.java      # Handler principal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ service/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AuthenticationService.java  # L√≥gica de auth
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ JwtService.java             # Gera√ß√£o/valida√ß√£o JWT
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ClienteService.java         # Consulta RDS
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CpfValidator.java           # Valida√ß√£o CPF
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AuthRequest.java            # DTO request
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AuthResponse.java           # DTO response
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Cliente.java                # Model cliente
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ClienteDto.java             # DTO cliente
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ util/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ JwtAuthorizerHandler.java   # JWT Authorizer
‚îÇ   ‚îú‚îÄ‚îÄ src/test/java/             # Testes unit√°rios
‚îÇ   ‚îú‚îÄ‚îÄ pom.xml                   # Depend√™ncias Maven
‚îÇ   ‚îú‚îÄ‚îÄ template.yml              # SAM template (alternativo)
‚îÇ   ‚îî‚îÄ‚îÄ README.md                 # Doc espec√≠fica
‚îú‚îÄ‚îÄ applications/                 # Apps migradas da Fase 2
‚îÇ   ‚îú‚îÄ‚îÄ autoatendimento/          # API principal (Clean Architecture)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/main/java/br/com/lanchonete/autoatendimento/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dominio/          # Entities, VOs, Enums
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ aplicacao/        # Use Cases, Gateways
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adaptadores/      # Controllers, Repositories
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ infra/            # Configuration, Security
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/main/resources/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application.yml   # Config base
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application-kubernetes.yml  # Config EKS
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schema-mysql.sql  # Schema
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ data-mysql.sql    # Dados iniciais
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile            # Container
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pom.xml              # Depend√™ncias
‚îÇ   ‚îî‚îÄ‚îÄ pagamento/               # Mock Mercado Pago
‚îÇ       ‚îú‚îÄ‚îÄ src/main/java/br/com/lanchonete/pagamento/
‚îÇ       ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ       ‚îî‚îÄ‚îÄ pom.xml
‚îú‚îÄ‚îÄ k8s-manifests/               # Kubernetes YAML
‚îÇ   ‚îú‚îÄ‚îÄ applications/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ autoatendimento-deployment.yaml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pagamento-deployment.yaml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services.yaml        # ClusterIP services
‚îÇ   ‚îú‚îÄ‚îÄ configmaps/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ autoatendimento-configmap.yaml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pagamento-configmap.yaml
‚îÇ   ‚îú‚îÄ‚îÄ secrets/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ create-secrets.sh    # Script para secrets
‚îÇ   ‚îú‚îÄ‚îÄ hpa/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ autoatendimento-hpa.yaml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pagamento-hpa.yaml
‚îÇ   ‚îî‚îÄ‚îÄ ingress/
‚îÇ       ‚îî‚îÄ‚îÄ alb-ingress.yaml     # ALB Ingress Controller
‚îú‚îÄ‚îÄ docs/                        # Documenta√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ architecture/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ architecture-overview.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database-design.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api-flows.md
‚îÇ   ‚îú‚îÄ‚îÄ deployment/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ aws-academy-setup.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ troubleshooting.md
‚îÇ   ‚îî‚îÄ‚îÄ diagrams/               # Diagramas arquiteturais
‚îú‚îÄ‚îÄ scripts/                    # Scripts utilit√°rios
‚îÇ   ‚îú‚îÄ‚îÄ setup-aws-academy.sh   # Setup inicial AWS Academy
‚îÇ   ‚îú‚îÄ‚îÄ deploy-all.sh          # Deploy completo ordenado
‚îÇ   ‚îú‚îÄ‚îÄ test-complete-flow.sh  # Teste end-to-end via cURL
‚îÇ   ‚îú‚îÄ‚îÄ test-endpoints.sh      # Teste individual de APIs
‚îÇ   ‚îî‚îÄ‚îÄ cleanup-all.sh         # Limpeza completa
‚îú‚îÄ‚îÄ .gitignore                 # Git ignore
‚îú‚îÄ‚îÄ README.md                  # Documenta√ß√£o principal
‚îî‚îÄ‚îÄ VIDEO.md                   # Link e descri√ß√£o do v√≠deo
```

## üîë ESPECIFICA√á√ÉO DA LAMBDA DE AUTENTICA√á√ÉO

### AuthHandler.java
```java
// Caracter√≠sticas t√©cnicas:
// - Implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent>
// - Runtime: java17
// - Handler: br.com.lanchonete.auth.AuthHandler::handleRequest
// - Memory: 512MB
// - Timeout: 30s
// - Environment variables: JWT_SECRET, DATABASE_URL, DB_USERNAME, DB_PASSWORD
// - IAM Role: LabRole (AWS Academy)

// Funcionalidades:
// 1. Recebe { "cpf": "12345678901", "authType": "customer" } OU { "authType": "anonymous" }
// 2. Valida CPF se fornecido
// 3. Busca cliente no RDS MySQL via JDBC
// 4. Gera JWT com dados do cliente ou sessionId para an√¥nimos
// 5. Retorna { token, authType, cliente?, sessionId?, expiresIn }
// 6. Trata erros: CPF inv√°lido (400), Cliente n√£o encontrado (404), Erro interno (500)
```

### AuthenticationService.java
```java
// L√≥gica principal:
// - authenticate(AuthRequest): entry point
// - authenticateCustomer(String cpf): fluxo CPF
// - authenticateAnonymous(): fluxo an√¥nimo
// - Valida√ß√µes: CPF format, cliente exists
// - Integra√ß√£o: ClienteService, JwtService, CpfValidator
```

### JwtService.java
```java
// JWT Management:
// - generateCustomerToken(Cliente): JWT com dados pessoais
// - generateAnonymousToken(String sessionId): JWT com sessionId
// - validateToken(String token): valida√ß√£o de assinatura e expira√ß√£o
// - getClaims(String token): extra√ß√£o de dados
// - Algorithm: HMAC256
// - Issuer: "lanchonete-auth"
// - Expiration: 1 hora
```

### JWT Authorizer (Separado)
```java
// JwtAuthorizerHandler.java
// - Handler para API Gateway Custom Authorizer
// - Input: { "authorizationToken": "Bearer jwt...", "methodArn": "..." }
// - Output: IAM Policy + Context com dados do usu√°rio
// - Context injetado: clienteId, cpf, nome, authType, sessionId
// - Headers injetados na aplica√ß√£o: X-Cliente-ID, X-Cliente-CPF, X-Auth-Type, X-Session-ID
```

### ClienteService.java
```java
// Database Integration:
// - Conex√£o direta JDBC com RDS MySQL
// - buscarPorCpf(String cpf): SELECT * FROM clientes WHERE cpf = ?
// - Connection string via environment variable
// - Error handling para SQLException
```

## üóÑÔ∏è ESPECIFICA√á√ÉO DO BANCO DE DADOS

### Justificativa T√©cnica - MySQL
```
Por que MySQL:
‚úÖ ACID Compliance: Essencial para pedidos e pagamentos
‚úÖ Schema Relacional: Adequado para dom√≠nio lanchonete
‚úÖ RDS Gerenciado: Backups, patches, monitoramento autom√°ticos
‚úÖ Performance Read-Heavy: Otimizado para consultas (produtos, pedidos)
‚úÖ Custo-Benef√≠cio: Mais econ√¥mico que NoSQL gerenciados
‚úÖ Maturidade: 25+ anos de estabilidade
‚úÖ Skillset: Conhecimento amplamente dispon√≠vel
```

### Schema Principal
```sql
-- Clientes (CPF √∫nico, campos obrigat√≥rios)
CREATE TABLE clientes (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    nome VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE,
    cpf VARCHAR(11) UNIQUE NOT NULL,
    data_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_cpf (cpf)
);

-- Produtos (categorias fixas, pre√ßos decimais)
CREATE TABLE produtos (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    nome VARCHAR(255) NOT NULL,
    categoria ENUM('LANCHE','BEBIDA','ACOMPANHAMENTO','SOBREMESA') NOT NULL,
    preco DECIMAL(10,2) NOT NULL,
    descricao TEXT,
    ativo BOOLEAN DEFAULT TRUE,
    data_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_categoria (categoria),
    INDEX idx_ativo (ativo)
);

-- Pedidos (relacionamento opcional com cliente)
CREATE TABLE pedidos (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    cliente_id BIGINT NULL,  -- NULL para pedidos an√¥nimos
    status ENUM('RECEBIDO','EM_PREPARACAO','PRONTO','FINALIZADO') DEFAULT 'RECEBIDO',
    status_pagamento ENUM('PENDENTE','APROVADO','REJEITADO') DEFAULT 'PENDENTE',
    valor_total DECIMAL(10,2) NOT NULL,
    data_criacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    data_atualizacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (cliente_id) REFERENCES clientes(id) ON DELETE SET NULL,
    INDEX idx_cliente (cliente_id),
    INDEX idx_status (status),
    INDEX idx_status_pagamento (status_pagamento),
    INDEX idx_data_criacao (data_criacao)
);

-- Itens do pedido (relacionamento N:N com produtos)
CREATE TABLE itens_pedido (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    pedido_id BIGINT NOT NULL,
    produto_id BIGINT NOT NULL,
    quantidade INT NOT NULL,
    preco_unitario DECIMAL(10,2) NOT NULL,  -- Snapshot do pre√ßo
    FOREIGN KEY (pedido_id) REFERENCES pedidos(id) ON DELETE CASCADE,
    FOREIGN KEY (produto_id) REFERENCES produtos(id),
    INDEX idx_pedido (pedido_id),
    INDEX idx_produto (produto_id)
);
```

### Dados de Exemplo (Seed)
```sql
-- Clientes de teste
INSERT INTO clientes (nome, email, cpf) VALUES
('Jo√£o Silva', 'joao@email.com', '12345678901'),
('Maria Santos', 'maria@email.com', '98765432100'),
('Pedro Oliveira', 'pedro@email.com', '11122233344');

-- Produtos por categoria
INSERT INTO produtos (nome, categoria, preco, descricao) VALUES
-- Lanches
('Big Burguer', 'LANCHE', 25.90, 'Hamb√∫rguer artesanal com carne de 200g'),
('Cheese Burguer', 'LANCHE', 22.50, 'Hamb√∫rguer com queijo cheddar'),
('Bacon Burguer', 'LANCHE', 27.90, 'Hamb√∫rguer com bacon crocante'),
-- Bebidas
('Coca-Cola', 'BEBIDA', 6.00, 'Refrigerante Coca-Cola 350ml'),
('Suco Natural', 'BEBIDA', 8.50, 'Suco natural de laranja 400ml'),
-- Acompanhamentos
('Batata Frita', 'ACOMPANHAMENTO', 8.90, 'Batata frita crocante'),
('Onion Rings', 'ACOMPANHAMENTO', 10.90, 'An√©is de cebola empanados'),
-- Sobremesas
('Sorvete', 'SOBREMESA', 12.90, 'Sorvete artesanal 2 bolas'),
('Brownie', 'SOBREMESA', 14.90, 'Brownie com calda de chocolate');
```

### Configura√ß√£o RDS
```hcl
# terraform/database/rds.tf
resource "aws_db_instance" "mysql" {
  identifier = "lanchonete-mysql"
  engine = "mysql"
  engine_version = "8.0"
  instance_class = "db.t3.micro"  # Free tier compatible
  
  allocated_storage = 20
  storage_type = "gp2"
  storage_encrypted = false  # Academy limitation
  
  db_name = "lanchonete"
  username = var.db_username
  password = var.db_password
  
  vpc_security_group_ids = [aws_security_group.rds.id]
  db_subnet_group_name = aws_db_subnet_group.default.name
  
  backup_retention_period = 7
  backup_window = "03:00-04:00"
  maintenance_window = "sun:04:00-sun:05:00"
  
  skip_final_snapshot = true  # Para ambiente de desenvolvimento
  deletion_protection = false
  
  tags = {
    Name = "lanchonete-mysql"
    Environment = "academy"
  }
}
```

## ‚ò∏Ô∏è ESPECIFICA√á√ÉO DO KUBERNETES

### Adapta√ß√µes para AWS Academy
```yaml
# Mudan√ßas principais da Fase 2 ‚Üí Fase 3:
# 1. Services: NodePort ‚Üí ClusterIP (acesso via ALB)
# 2. Security: Context injection via headers API Gateway
# 3. Database: MySQL local ‚Üí RDS endpoint
# 4. Scaling: Mantido HPA (CPU/Memory based)
```

### Security Filter Adaptado
```java
// applications/autoatendimento/src/main/java/.../infra/ApiGatewayContextFilter.java
@Component
public class ApiGatewayContextFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) {

        // Extrair context injetado pelo API Gateway JWT Authorizer
        String clienteId = request.getHeader("X-Cliente-ID");
        String cpf = request.getHeader("X-Cliente-CPF");
        String nome = request.getHeader("X-Cliente-Nome");
        String authType = request.getHeader("X-Auth-Type");
        String sessionId = request.getHeader("X-Session-ID");

        // Criar Authentication baseado no tipo
        if ("customer".equals(authType) && clienteId != null) {
            CustomerAuthenticationToken auth = new CustomerAuthenticationToken(
                Long.valueOf(clienteId), cpf, nome,
                List.of(new SimpleGrantedAuthority("ROLE_CUSTOMER"))
            );
            SecurityContextHolder.getContext().setAuthentication(auth);
            
        } else if ("anonymous".equals(authType) && sessionId != null) {
            AnonymousAuthenticationToken auth = new AnonymousAuthenticationToken(
                sessionId, "anonymous",
                List.of(new SimpleGrantedAuthority("ROLE_ANONYMOUS"))
            );
            SecurityContextHolder.getContext().setAuthentication(auth);
        }

        filterChain.doFilter(request, response);
    }
}
```

### ALB Ingress Controller
```yaml
# k8s-manifests/ingress/alb-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: lanchonete-alb
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internal
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}]'
    alb.ingress.kubernetes.io/healthcheck-path: /actuator/health
spec:
  rules:
    - http:
        paths:
          - path: /produtos
            pathType: Prefix
            backend:
              service:
                name: autoatendimento-service
                port:
                  number: 80
          - path: /pedidos
            pathType: Prefix
            backend:
              service:
                name: autoatendimento-service
                port:
                  number: 80
          - path: /clientes
            pathType: Prefix
            backend:
              service:
                name: autoatendimento-service
                port:
                  number: 80
          - path: /pagamentos
            pathType: Prefix
            backend:
              service:
                name: pagamento-service
                port:
                  number: 80
```

## üåê ESPECIFICA√á√ÉO DO API GATEWAY

### Estrutura de Routes
```
P√∫blicas (sem autentica√ß√£o):
POST /auth                    ‚Üí Lambda (√∫nica rota p√∫blica)
GET  /health                 ‚Üí Lambda (health check)

Protegidas (JWT Authorizer):
GET  /produtos/categoria/{categoria}  ‚Üí EKS via VPC Link
POST /produtos                       ‚Üí EKS (admin - futuro)
GET  /clientes/cpf/{cpf}            ‚Üí EKS
POST /clientes                      ‚Üí EKS
GET  /pedidos                       ‚Üí EKS
GET  /pedidos/{id}                  ‚Üí EKS
GET  /pedidos/cozinha               ‚Üí EKS
POST /pedidos/checkout              ‚Üí EKS
PUT  /pedidos/{id}/status           ‚Üí EKS
POST /pagamentos                    ‚Üí EKS
GET  /pagamentos/{id}/status        ‚Üí EKS
POST /webhook/pagamento             ‚Üí EKS (sem auth - webhook externo)
```

### Terraform API Gateway
```hcl
# terraform/lambda/api-gateway.tf
resource "aws_api_gateway_rest_api" "lanchonete_api" {
  name = "lanchonete-api"
  description = "API Gateway para sistema de lanchonete"
  
  endpoint_configuration {
    types = ["REGIONAL"]
  }
}

# JWT Custom Authorizer
resource "aws_api_gateway_authorizer" "jwt_authorizer" {
  name = "jwt-authorizer"
  rest_api_id = aws_api_gateway_rest_api.lanchonete_api.id
  authorizer_uri = aws_lambda_function.jwt_authorizer.invoke_arn
  authorizer_credentials = data.aws_iam_role.lab_role.arn
  type = "TOKEN"
  identity_source = "method.request.header.Authorization"
  authorizer_result_ttl_in_seconds = 300  # Cache por 5 minutos
}

# VPC Link para EKS
resource "aws_api_gateway_vpc_link" "eks_vpc_link" {
  name = "eks-vpc-link"
  description = "VPC Link para conectar com EKS"
  target_arns = [aws_lb.alb.arn]
}
```

### Context Injection Configuration
```hcl
# Headers injetados pelo authorizer para aplica√ß√£o
resource "aws_api_gateway_integration" "produtos_integration" {
  rest_api_id = aws_api_gateway_rest_api.lanchonete_api.id
  resource_id = aws_api_gateway_resource.produtos_categoria_param.id
  http_method = aws_api_gateway_method.produtos_get.http_method

  type = "HTTP_PROXY"
  integration_http_method = "GET"
  uri = "http://${aws_lb.alb.dns_name}/produtos/categoria/{categoria}"
  
  connection_type = "VPC_LINK"
  connection_id = aws_api_gateway_vpc_link.eks_vpc_link.id

  request_parameters = {
    "integration.request.path.categoria" = "method.request.path.categoria"
    "integration.request.header.X-Cliente-ID" = "context.authorizer.clienteId"
    "integration.request.header.X-Cliente-CPF" = "context.authorizer.cpf"
    "integration.request.header.X-Cliente-Nome" = "context.authorizer.nome"
    "integration.request.header.X-Auth-Type" = "context.authorizer.authType"
    "integration.request.header.X-Session-ID" = "context.authorizer.sessionId"
  }
}
```

## üöÄ ESPECIFICA√á√ÉO DO CI/CD

### GitHub Actions Strategy
```yaml
# Path-based deployment com 4 workflows principais:

# 1. deploy-lambda.yml (paths: lambda-auth/**, terraform/lambda/**)
# - Maven build + test
# - JAR packaging
# - Terraform apply (Lambda + API Gateway)

# 2. deploy-infra-db.yml (paths: terraform/database/**)
# - Terraform plan/apply
# - Run migrations
# - Validate connectivity

# 3. deploy-infra-k8s.yml (paths: terraform/kubernetes/**, k8s-manifests/**)
# - Terraform apply (EKS + VPC Link + ALB)
# - Update kubectl config
# - Apply K8s manifests

# 4. deploy-applications.yml (paths: applications/**)
# - Multi-stage Docker build
# - Push to ECR
# - Rolling update in EKS
```

### Secrets Management
```yaml
# GitHub Repository Secrets necess√°rios:
AWS_ACCESS_KEY_ID         # AWS Academy
AWS_SECRET_ACCESS_KEY     # AWS Academy  
AWS_SESSION_TOKEN         # AWS Academy (obrigat√≥rio)
JWT_SECRET                # Chave para assinar JWTs
DB_USERNAME               # Username RDS
DB_PASSWORD               # Password RDS
SOAT_USER_ACCESS          # Para adicionar soatarchitecture
```

### Branch Protection Rules
```yaml
# main branch:
required_status_checks:
  - "ci/lambda-tests"
  - "ci/terraform-plan-db" 
  - "ci/terraform-plan-k8s"
  - "ci/app-tests"
required_pull_request_reviews:
  required_approving_review_count: 1
enforce_admins: true
restrict_pushes: true
```

## üß™ ESPECIFICA√á√ÉO DE TESTES

### Teste Completo via cURL
```bash
#!/bin/bash
# scripts/test-complete-flow.sh

API_BASE="https://api.lanchonete.com"

echo "üîë 1. AUTENTICA√á√ÉO COM CPF"
CUSTOMER_RESPONSE=$(curl -s -X POST "$API_BASE/auth" \
  -H "Content-Type: application/json" \
  -d '{"cpf": "12345678901", "authType": "customer"}')
  
CUSTOMER_TOKEN=$(echo $CUSTOMER_RESPONSE | jq -r '.token')

echo "üë§ 2. AUTENTICA√á√ÉO AN√îNIMA" 
ANON_RESPONSE=$(curl -s -X POST "$API_BASE/auth" \
  -H "Content-Type: application/json" \
  -d '{"authType": "anonymous"}')
  
ANON_TOKEN=$(echo $ANON_RESPONSE | jq -r '.token')

echo "üçî 3. LISTAR PRODUTOS (Cliente)"
curl -X GET "$API_BASE/produtos/categoria/LANCHE" \
  -H "Authorization: Bearer $CUSTOMER_TOKEN" | jq .

echo "üçî 4. LISTAR PRODUTOS (An√¥nimo)"
curl -X GET "$API_BASE/produtos/categoria/LANCHE" \
  -H "Authorization: Bearer $ANON_TOKEN" | jq .

echo "üõí 5. CHECKOUT CLIENTE"
PEDIDO_CUSTOMER=$(curl -s -X POST "$API_BASE/pedidos/checkout" \
  -H "Authorization: Bearer $CUSTOMER_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"itens": [{"produtoId": 1, "quantidade": 1}]}')
  
echo "üõí 6. CHECKOUT AN√îNIMO"
PEDIDO_ANON=$(curl -s -X POST "$API_BASE/pedidos/checkout" \
  -H "Authorization: Bearer $ANON_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"itens": [{"produtoId": 2, "quantidade": 1}]}')

echo "üí≥ 7. PROCESSAR PAGAMENTOS"
# Processar ambos pagamentos

echo "üìä 8. CONSULTAR COZINHA"
curl -X GET "$API_BASE/pedidos/cozinha" \
  -H "Authorization: Bearer $CUSTOMER_TOKEN" | jq .
```

### Cen√°rios de Valida√ß√£o
```
‚úÖ Autentica√ß√£o CPF v√°lido ‚Üí JWT com dados pessoais
‚úÖ Autentica√ß√£o an√¥nima ‚Üí JWT com sessionId
‚úÖ JWT inv√°lido ‚Üí 401 Unauthorized
‚úÖ JWT expirado ‚Üí 401 Unauthorized
‚úÖ Produtos ‚Üí Mesma resposta para ambos tipos
### Funcionalidade Requirements  
```yaml
‚úÖ Autentica√ß√£o CPF gerando JWT com dados pessoais
‚úÖ Autentica√ß√£o an√¥nima gerando JWT com sessionId
‚úÖ Context injection funcionando (headers X-*)
‚úÖ CRUD produtos com autentica√ß√£o
‚úÖ Checkout identificado (clienteId preenchido)
‚úÖ Checkout an√¥nimo (clienteId null)
‚úÖ Processamento pagamentos via mock
‚úÖ Webhook pagamento funcionando
‚úÖ Consulta pedidos cozinha
‚úÖ Fluxo completo via cURL testado
```

### V√≠deo Requirements
```yaml
‚úÖ Dura√ß√£o 45-60 minutos
‚úÖ Mostra todos servi√ßos AWS criados
‚úÖ Explica fun√ß√£o de cada componente
‚úÖ Demonstra aplica√ß√£o funcionando end-to-end
‚úÖ Exibe GitHub Actions com checks verdes
‚úÖ Mostra Pull Requests fechados
‚úÖ Justifica escolhas t√©cnicas (MySQL, sem Cognito)
‚úÖ Evidencia adapta√ß√µes AWS Academy
‚úÖ Upload YouTube/Vimeo (p√∫blico ou n√£o listado)
‚úÖ Link dispon√≠vel no reposit√≥rio
```

### Documentation Requirements
```yaml
‚úÖ Justificativa t√©cnica escolha MySQL
‚úÖ Explica√ß√£o por que n√£o usar Cognito  
‚úÖ Documenta√ß√£o adapta√ß√µes AWS Academy
‚úÖ Diagramas arquiteturais
‚úÖ Guias de setup e troubleshooting
‚úÖ Modelagem de dados documentada
‚úÖ APIs documentadas (Swagger/OpenAPI)
‚úÖ Context injection pattern explicado
```

## üéØ CRIT√âRIOS DE SUCESSO

### T√©cnicos
```yaml
‚úÖ Sistema funcionando 100% end-to-end via cURL
‚úÖ Autentica√ß√£o dual (CPF + an√¥nimo) funcionando
‚úÖ JWT Authorizer validando e injetando context
‚úÖ Aplica√ß√µes recebendo dados corretos via headers
‚úÖ Database queries funcionando (RDS MySQL)
‚úÖ CI/CD executando sem erros
‚úÖ Infraestrutura toda via Terraform
‚úÖ Zero hardcoded secrets
```

### Demonstra√ß√£o
```yaml
‚úÖ Professor consegue reproduzir todos testes
‚úÖ APIs respondem corretamente via cURL
‚úÖ Context √© injetado corretamente (logs evidenciam)
‚úÖ Cliente identificado vs an√¥nimo funcionam diferentes
‚úÖ Pedidos ficam vinculados corretamente ao cliente
‚úÖ GitHub Actions mostra deployments autom√°ticos
‚úÖ Arquitetura AWS vis√≠vel e explicada
```

### Qualidade
```yaml
‚úÖ C√≥digo limpo e bem estruturado
‚úÖ Arquitetura respeitando Clean Architecture
‚úÖ Logs estruturados para debugging
‚úÖ Error handling adequado
‚úÖ Performance otimizada para ambiente Academy
‚úÖ Security best practices aplicadas
‚úÖ Documenta√ß√£o completa e clara
```

---

## üìù LOG DE ATUALIZA√á√ïES AUTOM√ÅTICAS
*Esta se√ß√£o ser√° mantida pelo Claude Code para rastrear mudan√ßas de status e commits*

### Status das Etapas
```
Data       | Etapa | Status Anterior | Status Novo | Usu√°rio
-----------|-------|-----------------|-------------|--------
2025-08-30 | ETAPA 1 | [ ] TODO      | [X] DONE   | Usuario
```

### Hist√≥rico de Commits
```
Data       | Mensagem Sugerida                           | Status
-----------|---------------------------------------------|--------
(Aguardando primeiro grupo de artefatos)
```

---

## üöÄ COMANDO PARA CLAUDE CODE

Para gerar todos os artefatos com Claude Code, execute:

```bash
claude-code generate --from=CLAUDE.md --target=lanchonete-tech-challenge-fase3/
```

Este arquivo CLAUDE.md cont√©m todas as especifica√ß√µes t√©cnicas completas para implementar o Tech Challenge Fase 3 com arquitetura cloud-native na AWS Academy. cliente ‚Üí clienteId preenchido
‚úÖ Checkout an√¥nimo ‚Üí clienteId = null
‚úÖ Headers injetados ‚Üí Context correto na aplica√ß√£o
‚úÖ Pagamentos ‚Üí Webhook funcionando
‚úÖ Cozinha ‚Üí Lista todos pedidos
```

## üé¨ ESPECIFICA√á√ÉO DO V√çDEO

### Roteiro (45-60 minutos)
```
00:00-05:00  Introdu√ß√£o
             - Apresenta√ß√£o da equipe
             - Objetivos da Fase 3
             - Arquitetura geral na AWS

05:00-15:00  AWS Console Tour
             - API Gateway (routes, authorizer)
             - Lambda functions (logs, test)
             - EKS cluster (nodes, pods)
             - RDS MySQL (endpoint, security)
             - VPC Link (connection)

15:00-25:00  Demonstra√ß√£o via cURL
             - Autentica√ß√£o CPF + an√¥nimo
             - Listagem produtos
             - Checkout ambos fluxos
             - Processamento pagamentos
             - Consulta cozinha

25:00-35:00  GitHub Actions
             - Mostrar workflows (checks verdes)
             - Pull requests fechados
             - Deploy autom√°tico
             - Secrets configurados

35:00-45:00  Explica√ß√£o T√©cnica
             - Por que n√£o Cognito
             - Justificativa MySQL
             - Adapta√ß√µes AWS Academy
             - Context injection pattern

45:00-50:00  Considera√ß√µes Finais
             - Li√ß√µes aprendidas
             - Pr√≥ximos passos
             - Limpeza de recursos
```

### Pontos Obrigat√≥rios
```
‚úÖ Mostrar servi√ßos criados na cloud
‚úÖ Explicar fun√ß√£o de cada servi√ßo
‚úÖ Demonstrar aplica√ß√£o funcionando
‚úÖ Exibir pipelines CI/CD (checks verdes)
‚úÖ Justificar escolhas arquiteturais
‚úÖ Evidenciar branch protection
‚úÖ Mostrar Pull Requests fechados
```

## ‚öôÔ∏è CONFIGURA√á√ïES AWS ACADEMY

### Adapta√ß√µes Obrigat√≥rias
```yaml
# Todas as resources devem usar:
iam_role: data.aws_iam_role.lab_role.arn
region: us-east-1
vpc: data.aws_vpc.default (VPC padr√£o)

# Limita√ß√µes:
- N√£o pode criar IAM roles customizadas
- N√£o pode criar VPCs customizadas  
- Sess√£o expira em 4 horas
- Regi√£o limitada a us-east-1
- Budget limitado (~$100 por sess√£o)
```

### Terraform Academy Configuration
```hcl
# terraform/shared/variables.tf
variable "aws_region" {
  description = "AWS region (fixed for Academy)"
  type        = string
  default     = "us-east-1"
}

variable "lab_session_id" {
  description = "Academy lab session identifier"
  type        = string
  default     = ""
}

# terraform/shared/academy.tfvars
aws_region = "us-east-1"
lab_session_id = "academy-session-2024"
db_username = "lanchonete"
db_password = "LanchoneteAcademy123!"
jwt_secret = "academy-jwt-secret-super-strong-key-12345"
```

### Data Sources Obrigat√≥rios
```hcl
# terraform/shared/data.tf
data "aws_iam_role" "lab_role" {
  name = "LabRole"
}

data "aws_vpc" "default" {
  default = true
}

data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}

data "aws_availability_zones" "available" {
  state = "available"
}
```

## üìä ESPECIFICA√á√ÉO DE MONITORAMENTO

### CloudWatch Integration
```yaml
# Logs obrigat√≥rios para demonstra√ß√£o:
/aws/lambda/lanchonete-auth              # Lambda auth logs
/aws/apigateway/lanchonete-api           # API Gateway access logs
/aws/eks/lanchonete-cluster/cluster      # EKS cluster logs
/aws/rds/instance/lanchonete-mysql/error # RDS error logs

# M√©tricas importantes:
- Lambda: Duration, Errors, Throttles
- API Gateway: Count, Latency, 4xx/5xx errors  
- EKS: CPU, Memory, Pod restarts
- RDS: Connections, CPU, Read/Write IOPS
```

### Application Logs Pattern
```java
// Logs estruturados para troubleshooting
// lambda-auth/src/main/java/.../AuthHandler.java
@Override
public APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent input, Context context) {
    String requestId = context.getAwsRequestId();
    
    try {
        logger.info("Iniciando processamento de autenticacao - RequestId: {}", requestId);
        logger.debug("Corpo da requisicao recebido: {}", input.getBody());
        
        AuthRequest request = objectMapper.readValue(input.getBody(), AuthRequest.class);
        AuthResponse response = authService.authenticate(request);
        
        logger.info("Autenticacao realizada com sucesso - RequestId: {}, Tipo: {}, ClienteId: {}", 
                   requestId, response.getAuthType(), 
                   response.getCliente() != null ? response.getCliente().getId() : "null");
        
        return createSuccessResponse(response);
        
    } catch (ClienteNotFoundException e) {
        logger.warn("Cliente nao encontrado - RequestId: {}, CPF: {}", requestId, maskCpf(extractCpf(input)));
        return createErrorResponse(404, "Cliente n√£o encontrado", e.getMessage());
    } catch (Exception e) {
        logger.error("Erro interno na autenticacao - RequestId: {}, Erro: {}", requestId, e.getMessage(), e);
        return createErrorResponse(500, "Erro interno", "Verifique os logs");
    }
}
```

## üîí ESPECIFICA√á√ÉO DE SEGURAN√áA

### JWT Security Configuration
```java
// lambda-auth/src/main/java/.../JwtService.java
@Service
public class JwtService {
    
    private static final Logger logger = LoggerFactory.getLogger(JwtService.class);
    
    // Configura√ß√µes de seguran√ßa
    private static final String ALGORITHM = "HMAC256";
    private static final String ISSUER = "lanchonete-auth";
    private static final int EXPIRATION_SECONDS = 3600; // 1 hora
    
    @Value("${jwt.secret}")
    private String jwtSecret; // M√≠nimo 256 bits para HMAC256
    
    public String generateCustomerToken(Cliente cliente) {
        logger.debug("Gerando token JWT para cliente ID: {}", cliente.getId());
        
        return JWT.create()
                .withIssuer(ISSUER)
                .withSubject(cliente.getId().toString())
                .withClaim("cpf", cliente.getCpf())
                .withClaim("nome", cliente.getNome()) 
                .withClaim("email", cliente.getEmail())
                .withClaim("type", "customer")
                .withClaim("role", "CUSTOMER")
                .withIssuedAt(Date.from(Instant.now()))
                .withExpiresAt(Date.from(Instant.now().plusSeconds(EXPIRATION_SECONDS)))
                .sign(Algorithm.HMAC256(jwtSecret));
    }
    
    public boolean validateToken(String token) {
        try {
            JWTVerifier verifier = JWT.require(Algorithm.HMAC256(jwtSecret))
                    .withIssuer(ISSUER)
                    .build();
            DecodedJWT jwt = verifier.verify(token);
            
            // Verifica√ß√µes adicionais
            if (jwt.getExpiresAt().before(new Date())) {
                logger.warn("Token expirado detectado");
                return false;
            }
            
            return true;
        } catch (JWTVerificationException e) {
            logger.warn("Token inv√°lido: {}", e.getMessage());
            return false;
        }
    }
}
```

### Database Security
```sql
-- Configura√ß√µes de seguran√ßa MySQL
-- terraform/database/migrations/001_create_schema.sql

-- Criar usu√°rio espec√≠fico da aplica√ß√£o (n√£o root)
CREATE USER 'lanchonete_app'@'%' IDENTIFIED BY 'ComplexPassword123!';

-- Permiss√µes m√≠nimas necess√°rias
GRANT SELECT, INSERT, UPDATE ON lanchonete.clientes TO 'lanchonete_app'@'%';
GRANT SELECT ON lanchonete.produtos TO 'lanchonete_app'@'%';
GRANT SELECT, INSERT, UPDATE ON lanchonete.pedidos TO 'lanchonete_app'@'%';
GRANT SELECT, INSERT ON lanchonete.itens_pedido TO 'lanchonete_app'@'%';

-- Flush privileges
FLUSH PRIVILEGES;

-- √çndices para performance e seguran√ßa
CREATE INDEX idx_cpf_hash ON clientes(cpf); -- Busca r√°pida por CPF
CREATE INDEX idx_pedido_data ON pedidos(data_criacao); -- Consultas por data
CREATE INDEX idx_pedido_status ON pedidos(status, status_pagamento); -- Cozinha
```

### Network Security
```hcl
# terraform/database/security-groups.tf
resource "aws_security_group" "rds" {
  name_prefix = "lanchonete-rds-"
  description = "Security group for RDS MySQL"
  vpc_id      = data.aws_vpc.default.id

  # Apenas Lambda e EKS podem acessar
  ingress {
    from_port   = 3306
    to_port     = 3306
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/8"] # VPC interna apenas
  }
  
  # Sem acesso externo direto
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  tags = {
    Name = "lanchonete-rds-sg"
  }
}

resource "aws_security_group" "lambda" {
  name_prefix = "lanchonete-lambda-"
  description = "Security group for Lambda functions"
  vpc_id      = data.aws_vpc.default.id

  # Lambda precisa acessar RDS
  egress {
    from_port   = 3306
    to_port     = 3306
    protocol    = "tcp" 
    cidr_blocks = ["10.0.0.0/8"]
  }
  
  # Lambda precisa internet para logs CloudWatch
  egress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
```

## üìà ESPECIFICA√á√ÉO DE PERFORMANCE

### Lambda Optimization
```yaml
# Configura√ß√£o otimizada para performance
Runtime: java17
Memory: 512MB                    # Balan√ßo custo/performance
Timeout: 30s                     # Suficiente para DB queries
Reserved Concurrency: 10        # Controle de custos
Provisioned Concurrency: 2      # Reduzir cold starts (opcional)

# Otimiza√ß√µes JVM
Environment:
  JAVA_TOOL_OPTIONS: >-
    -XX:+TieredCompilation
    -XX:TieredStopAtLevel=1
    -Dspring.main.lazy-initialization=true
    -Dspring.jmx.enabled=false
```

### EKS Performance Configuration
```yaml
# k8s-manifests/applications/autoatendimento-deployment.yaml
spec:
  replicas: 2                    # M√≠nimo para HA
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0          # Zero downtime
      maxSurge: 1

  template:
    spec:
      containers:
        - name: app
          resources:
            requests:
              memory: "256Mi"    # Baseado em profiling
              cpu: "250m"        # 0.25 CPU
            limits:
              memory: "512Mi"    # Limite conservador  
              cpu: "500m"        # 0.5 CPU max
          
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 10
            
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 8080
            initialDelaySeconds: 60
            periodSeconds: 30
```

### Database Performance
```sql
-- Configura√ß√µes de performance MySQL
-- terraform/database/rds.tf parameter group
resource "aws_db_parameter_group" "mysql_params" {
  family = "mysql8.0"
  
  parameter {
    name  = "innodb_buffer_pool_size"
    value = "{DBInstanceClassMemory*3/4}"  # 75% da RAM
  }
  
  parameter {
    name  = "max_connections"
    value = "100"  # Suficiente para carga esperada
  }
  
  parameter {
    name  = "query_cache_type"
    value = "1"   # Enable query cache
  }
  
  parameter {
    name  = "query_cache_size"
    value = "33554432"  # 32MB
  }
}
```

## üõ†Ô∏è ESPECIFICA√á√ÉO DE SCRIPTS UTILIT√ÅRIOS

### Setup Script
```bash
#!/bin/bash
# scripts/setup-aws-academy.sh

set -e

echo "üéì CONFIGURANDO AMBIENTE AWS ACADEMY"
echo "===================================="

# 1. Verificar AWS CLI
if ! command -v aws &> /dev/null; then
    echo "‚ùå AWS CLI n√£o encontrado. Instale primeiro."
    exit 1
fi

# 2. Verificar credenciais Academy
echo "üîç Verificando credenciais AWS Academy..."
CALLER_IDENTITY=$(aws sts get-caller-identity 2>/dev/null || echo "error")

if [[ $CALLER_IDENTITY == "error" ]]; then
    echo "‚ùå Credenciais AWS n√£o configuradas!"
    echo "üí° No AWS Academy:"
    echo "   1. Acesse 'AWS Details'"
    echo "   2. Clique em 'AWS CLI'"
    echo "   3. Copie e execute os comandos export"
    exit 1
fi

# 3. Verificar se √© LabRole
ROLE_ARN=$(echo $CALLER_IDENTITY | jq -r '.Arn')
if [[ $ROLE_ARN == *"LabRole"* ]]; then
    echo "‚úÖ LabRole detectada: OK"
else
    echo "‚ö†Ô∏è  Warning: N√£o est√° usando LabRole - pode haver limita√ß√µes"
fi

# 4. Configurar regi√£o padr√£o
export AWS_DEFAULT_REGION=us-east-1
echo "‚úÖ Regi√£o configurada: $AWS_DEFAULT_REGION"

# 5. Verificar Terraform
if ! command -v terraform &> /dev/null; then
    echo "‚ùå Terraform n√£o encontrado. Instalando..."
    # Script de instala√ß√£o do Terraform aqui
fi

TERRAFORM_VERSION=$(terraform version -json | jq -r '.terraform_version')
echo "‚úÖ Terraform vers√£o: $TERRAFORM_VERSION"

# 6. Verificar kubectl
if ! command -v kubectl &> /dev/null; then
    echo "‚ùå kubectl n√£o encontrado. Instalando..."
    # Script de instala√ß√£o do kubectl aqui
fi

# 7. Verificar Docker
if ! command -v docker &> /dev/null; then
    echo "‚ùå Docker n√£o encontrado. Necess√°rio para build."
    exit 1
fi

echo ""
echo "‚úÖ AMBIENTE CONFIGURADO COM SUCESSO!"
echo "üí° Pr√≥ximos passos:"
echo "   1. ./scripts/deploy-all.sh"
echo "   2. ./scripts/test-complete-flow.sh"
echo ""
echo "‚ö†Ô∏è  LEMBRE-SE: Credenciais AWS Academy expiram em 4 horas!"
```

### Deploy All Script
```bash
#!/bin/bash
# scripts/deploy-all.sh

set -e

echo "üöÄ DEPLOY COMPLETO - TECH CHALLENGE FASE 3"
echo "=========================================="

# 1. Deploy Database
echo "üóÑÔ∏è 1/4 - DEPLOYANDO INFRAESTRUTURA DO BANCO..."
cd terraform/database
terraform init -upgrade
terraform plan -var-file="../shared/academy.tfvars"
terraform apply -var-file="../shared/academy.tfvars" -auto-approve

# Aguardar RDS ficar dispon√≠vel
echo "‚è≥ Aguardando RDS ficar dispon√≠vel (pode demorar 10-15 min)..."
sleep 300  # 5 minutos inicial
cd ../..

# 2. Build Lambda
echo "‚ö° 2/4 - BUILDING E DEPLOYANDO LAMBDA..."
cd lambda-auth
mvn clean package -DskipTests
cd ../terraform/lambda
terraform init -upgrade
terraform plan -var-file="../shared/academy.tfvars"
terraform apply -var-file="../shared/academy.tfvars" -auto-approve
cd ../..

# 3. Deploy Kubernetes
echo "‚ò∏Ô∏è 3/4 - DEPLOYANDO EKS (pode demorar 20-25 min)..."
cd terraform/kubernetes
terraform init -upgrade
terraform plan -var-file="../shared/academy.tfvars"
terraform apply -var-file="../shared/academy.tfvars" -auto-approve

# Configurar kubectl
CLUSTER_NAME=$(terraform output -raw cluster_name)
aws eks update-kubeconfig --region us-east-1 --name $CLUSTER_NAME
cd ../..

# Aguardar cluster ficar pronto
echo "‚è≥ Aguardando cluster EKS ficar pronto..."
kubectl wait --for=condition=Ready nodes --all --timeout=600s

# 4. Deploy Applications
echo "üì¶ 4/4 - DEPLOYANDO APLICA√á√ïES..."

# Build e push imagens (se ECR estiver configurado)
# docker build -t autoatendimento applications/autoatendimento/
# docker build -t pagamento applications/pagamento/

# Deploy manifests
kubectl apply -f k8s-manifests/configmaps/
kubectl apply -f k8s-manifests/secrets/ 
kubectl apply -f k8s-manifests/applications/
kubectl apply -f k8s-manifests/hpa/
kubectl apply -f k8s-manifests/ingress/

# Aguardar pods ficarem prontos
echo "‚è≥ Aguardando aplica√ß√µes ficarem prontas..."
kubectl wait --for=condition=ready pod -l app=autoatendimento --timeout=300s
kubectl wait --for=condition=ready pod -l app=pagamento --timeout=300s

echo ""
echo "‚úÖ DEPLOY COMPLETO FINALIZADO!"
echo "=============================="

# Mostrar URLs
API_GATEWAY_URL=$(cd terraform/lambda && terraform output -raw api_gateway_url)
echo "üåê API Gateway URL: $API_GATEWAY_URL"

ALB_ENDPOINT=$(kubectl get ingress lanchonete-alb -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
echo "üì° ALB Endpoint: $ALB_ENDPOINT"

echo ""
echo "üß™ PR√ìXIMO PASSO: Executar testes"
echo "   ./scripts/test-complete-flow.sh"
```

### Cleanup Script
```bash
#!/bin/bash
# scripts/cleanup-all.sh

set -e

echo "üßπ LIMPEZA COMPLETA DE RECURSOS AWS"
echo "=================================="

# 1. Limpar Kubernetes
echo "‚ò∏Ô∏è 1/4 - REMOVENDO RECURSOS KUBERNETES..."
if command -v kubectl &> /dev/null; then
    kubectl delete --all pods --grace-period=0 --force || true
    kubectl delete --all services || true
    kubectl delete --all deployments || true
    kubectl delete --all configmaps || true
    kubectl delete --all secrets || true
    kubectl delete --all ingress || true
    kubectl delete --all hpa || true
fi

# 2. Destroy Kubernetes Infrastructure
echo "üèóÔ∏è 2/4 - DESTRUINDO INFRAESTRUTURA EKS..."
cd terraform/kubernetes
terraform destroy -var-file="../shared/academy.tfvars" -auto-approve || true
cd ../..

# 3. Destroy Lambda
echo "‚ö° 3/4 - DESTRUINDO LAMBDA E API GATEWAY..."
cd terraform/lambda
terraform destroy -var-file="../shared/academy.tfvars" -auto-approve || true
cd ../..

# 4. Destroy Database (last)
echo "üóÑÔ∏è 4/4 - DESTRUINDO BANCO DE DADOS..."
cd terraform/database
terraform destroy -var-file="../shared/academy.tfvars" -auto-approve || true
cd ../..

echo ""
echo "‚úÖ LIMPEZA COMPLETA FINALIZADA!"
echo "=============================="
echo "üí∞ Recursos AWS removidos - custos zerados"
echo "üéì Academy budget preservado"
```

## üìù CHECKLIST DE ENTREGA

### Reposit√≥rio Requirements
```yaml
‚úÖ Reposit√≥rio privado criado
‚úÖ User soatarchitecture adicionado com acesso
‚úÖ Branch main protegida (require PR + reviews)
‚úÖ README.md principal completo e detalhado
‚úÖ VIDEO.md com link do YouTube/Vimeo
‚úÖ Estrutura monorepo organizada
‚úÖ .gitignore configurado (n√£o commitar secrets)
‚úÖ Pull Requests fechados (evid√™ncia de prote√ß√£o)
```

### C√≥digo Requirements
```yaml
‚úÖ Lambda Auth em Java 17 completa
‚úÖ Aplica√ß√µes migradas da Fase 2 (Clean Architecture)
‚úÖ Terraform para toda infraestrutura (adaptado LabRole)
‚úÖ Kubernetes manifests adaptados (ClusterIP + ALB)
‚úÖ GitHub Actions workflows (path-based deployment)
‚úÖ Scripts utilit√°rios completos
‚úÖ Testes unit√°rios (m√≠nimo 70% cobertura)
‚úÖ Documenta√ß√£o t√©cnica detalhada
```

### Infraestrutura Requirements
```yaml
‚úÖ API Gateway com routes completas + JWT Authorizer
‚úÖ Lambda de autentica√ß√£o deployada e funcionando
‚úÖ EKS cluster com aplica√ß√µes rodando
‚úÖ RDS MySQL com dados de seed
‚úÖ VPC Link conectando API Gateway ‚Üî EKS
‚úÖ ALB roteando tr√°fego interno
‚úÖ Security Groups configurados
‚úÖ CloudWatch logs habilitados
```

### Funcionalidade Requirements  
```yaml
‚úÖ Autentica√ß√£o CPF gerando JWT com dados pessoais
‚úÖ Autentica√ß√£o an√¥nima gerando JWT com sessionId
‚úÖ Context injection funcionando (headers X-*)
‚úÖ CRUD produtos com autentica√ß√£o
‚úÖ Checkout
- comandos de destroy s√≥ podem ser executados pelo usu√°rio
- a cada nova sess√£o, acesse a aws para saber se tem algum recurso rodando e avise o usu√°rio
- nenhum comando com -auto-approve
- a cada inicio de sessao, verifique se h√° recursos √≥rf√£os na aws que podem ser deletados
- all messages in brazilian portuguese