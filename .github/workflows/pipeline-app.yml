name: "Pipeline 4 - Application"

on:
  pull_request:
    branches: [main]
  workflow_dispatch:
  workflow_run:
    workflows: ["Pipeline 2 - Kubernetes", "Pipeline 3 - Authentication"]
    types: [completed]

env:
  AWS_REGION: us-east-1
  TF_VERSION: "1.5.0"

jobs:
  check-dependencies:
    name: "Verificar Pipelines Dependentes"
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - name: "‚úÖ Verificar status dos Pipelines"
        id: check
        run: |
          echo "Verificando pipelines dependentes..."
          # Por simplicidade, sempre executar se triggered
          echo "should_run=true" >> $GITHUB_OUTPUT

  app-deploy:
    name: "Deploy Applications"
    runs-on: ubuntu-latest
    needs: check-dependencies
    if: needs.check-dependencies.outputs.should_run == 'true'

    steps:
      - name: "üì• Checkout do c√≥digo"
        uses: actions/checkout@v4

      - name: "üîê Configurar credenciais AWS"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "‚òï Setup Java 17"
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: "üîß Setup Maven"
        uses: actions/setup-maven@v4

      - name: "üê≥ Setup Docker Buildx"
        uses: docker/setup-buildx-action@v3

      - name: "‚ò∏Ô∏è Setup kubectl"
        uses: azure/setup-kubectl@v3

      - name: "üß™ Validar credenciais AWS"
        run: |
          echo "Validando credenciais AWS..."
          aws sts get-caller-identity

      # Verificar todos os pr√©-requisitos
      - name: "üîç Verificar infraestrutura completa"
        id: check_infra
        run: |
          echo "Verificando toda a infraestrutura necess√°ria..."

          # Base Infrastructure
          echo "Verificando Base Infrastructure..."
          aws s3 ls s3://lanchonete-terraform-state-poc/ >/dev/null 2>&1 || {
            echo "‚ùå Backend S3 n√£o encontrado"
            exit 1
          }
          aws ecr describe-repositories --repository-names lanchonete-autoatendimento >/dev/null 2>&1 || {
            echo "‚ùå ECR repositories n√£o encontrados"
            exit 1
          }
          aws rds describe-db-instances --db-instance-identifier lanchonete-mysql >/dev/null 2>&1 || {
            echo "‚ùå RDS n√£o encontrado"
            exit 1
          }
          echo "‚úÖ Base Infrastructure OK"

          # Kubernetes Infrastructure
          echo "Verificando Kubernetes Infrastructure..."
          aws eks describe-cluster --name lanchonete-cluster >/dev/null 2>&1 || {
            echo "‚ùå Cluster EKS n√£o encontrado"
            exit 1
          }
          echo "‚úÖ Kubernetes Infrastructure OK"

          # Authentication Infrastructure
          echo "Verificando Authentication Infrastructure..."
          aws lambda get-function --function-name lanchonete-auth >/dev/null 2>&1 || {
            echo "‚ùå Lambda de autentica√ß√£o n√£o encontrada"
            exit 1
          }
          echo "‚úÖ Authentication Infrastructure OK"

      # Obter URLs e configura√ß√µes do Terraform State
      - name: "üì§ Obter configura√ß√µes da infraestrutura"
        id: get_config
        run: |
          echo "Obtendo configura√ß√µes da infraestrutura..."

          # ECR URLs
          cd infra/ecr
          terraform init -backend-config="bucket=lanchonete-terraform-state-poc"
          ECR_AUTOATENDIMENTO=$(terraform output -raw ecr_autoatendimento_url)
          ECR_PAGAMENTO=$(terraform output -raw ecr_pagamento_url)
          echo "ecr_autoatendimento=$ECR_AUTOATENDIMENTO" >> $GITHUB_OUTPUT
          echo "ecr_pagamento=$ECR_PAGAMENTO" >> $GITHUB_OUTPUT
          cd ../..

          # RDS Endpoint
          cd infra/database
          terraform init -backend-config="bucket=lanchonete-terraform-state-poc"
          RDS_ENDPOINT=$(terraform output -raw db_endpoint)
          echo "rds_endpoint=$RDS_ENDPOINT" >> $GITHUB_OUTPUT
          cd ../..

          # API Gateway URL
          cd infra/api-gateway
          terraform init -backend-config="bucket=lanchonete-terraform-state-poc"
          API_GATEWAY_URL=$(terraform output -raw api_gateway_endpoint)
          echo "api_gateway_url=$API_GATEWAY_URL" >> $GITHUB_OUTPUT
          cd ../..

          echo "ECR Autoatendimento: $ECR_AUTOATENDIMENTO"
          echo "ECR Pagamento: $ECR_PAGAMENTO"
          echo "RDS Endpoint: $RDS_ENDPOINT"
          echo "API Gateway: $API_GATEWAY_URL"

      # Unit Tests Java
      - name: "üß™ Executar Unit Tests - Autoatendimento"
        working-directory: autoatendimento
        run: |
          echo "Executando testes unit√°rios do Autoatendimento..."
          mvn test
          echo "‚úÖ Testes do Autoatendimento conclu√≠dos"

      - name: "üß™ Executar Unit Tests - Pagamento"
        working-directory: pagamento
        run: |
          echo "Executando testes unit√°rios do Pagamento..."
          mvn test
          echo "‚úÖ Testes do Pagamento conclu√≠dos"

      # Build das aplica√ß√µes
      - name: "üî® Build Maven - Autoatendimento"
        working-directory: autoatendimento
        run: |
          echo "Compilando aplica√ß√£o Autoatendimento..."
          mvn clean package -DskipTests
          echo "‚úÖ Build do Autoatendimento conclu√≠do"

      - name: "üî® Build Maven - Pagamento"
        working-directory: pagamento
        run: |
          echo "Compilando aplica√ß√£o Pagamento..."
          mvn clean package -DskipTests
          echo "‚úÖ Build do Pagamento conclu√≠do"

      # Login no ECR
      - name: "üîê Login no ECR"
        run: |
          echo "Fazendo login no ECR..."
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ steps.get_config.outputs.ecr_autoatendimento }}

      # Build e Push das imagens Docker
      - name: "üê≥ Build e Push - Autoatendimento"
        working-directory: autoatendimento
        run: |
          echo "Construindo imagem Docker do Autoatendimento..."
          docker build -t lanchonete-autoatendimento:latest .
          docker tag lanchonete-autoatendimento:latest ${{ steps.get_config.outputs.ecr_autoatendimento }}:latest
          docker push ${{ steps.get_config.outputs.ecr_autoatendimento }}:latest
          echo "‚úÖ Imagem do Autoatendimento enviada para ECR"

      - name: "üê≥ Build e Push - Pagamento"
        working-directory: pagamento
        run: |
          echo "Construindo imagem Docker do Pagamento..."
          docker build -t lanchonete-pagamento:latest .
          docker tag lanchonete-pagamento:latest ${{ steps.get_config.outputs.ecr_pagamento }}:latest
          docker push ${{ steps.get_config.outputs.ecr_pagamento }}:latest
          echo "‚úÖ Imagem do Pagamento enviada para ECR"

      # Configurar kubectl
      - name: "‚ò∏Ô∏è Configurar kubectl"
        run: |
          echo "Configurando kubectl para o cluster EKS..."
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name lanchonete-cluster
          kubectl version --client
          kubectl get nodes

      # Atualizar manifests com URLs din√¢micas
      - name: "üìù Atualizar Kubernetes Manifests"
        run: |
          echo "Atualizando manifests com URLs do ECR..."

          # Obter ID da conta AWS
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

          # Atualizar deployments com URLs corretas
          find k8s_manifests -name "*.yaml" -o -name "*.yml" | while read file; do
            sed -i "s|[0-9]\{12\}\.dkr\.ecr\.us-east-1\.amazonaws\.com|${ACCOUNT_ID}.dkr.ecr.us-east-1.amazonaws.com|g" "$file"
            echo "Atualizado: $file"
          done

      # Criar secrets do RDS
      - name: "üîê Criar Kubernetes Secrets"
        run: |
          echo "Criando secrets do RDS..."

          # Obter senha do Parameter Store
          RDS_PASSWORD=$(aws ssm get-parameter \
            --name "/lanchonete/rds/password" \
            --with-decryption \
            --query 'Parameter.Value' \
            --output text)

          # Criar secret se n√£o existir
          kubectl create secret generic mysql-secret \
            --from-literal=host=${{ steps.get_config.outputs.rds_endpoint }} \
            --from-literal=username=admin \
            --from-literal=password="${RDS_PASSWORD}" \
            --from-literal=database=lanchonete \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "‚úÖ Secrets criados/atualizados"

      # Deploy no Kubernetes
      - name: "üöÄ Deploy Aplica√ß√µes no Kubernetes"
        run: |
          echo "Fazendo deploy das aplica√ß√µes..."

          # Deploy dos manifestos
          kubectl apply -f k8s_manifests/

          # Aguardar pods ficarem prontos
          echo "Aguardando pods ficarem prontos..."
          kubectl wait --for=condition=ready pod -l app=autoatendimento --timeout=300s || true
          kubectl wait --for=condition=ready pod -l app=pagamento --timeout=300s || true

          # Verificar status
          kubectl get pods
          kubectl get services
          kubectl get ingress

      # Aguardar ALBs ficarem ativos
      - name: "‚è≥ Aguardar ALBs ficarem ativos"
        id: alb_wait
        run: |
          echo "Aguardando ALBs serem provisionados (pode levar 3-5 minutos)..."

          MAX_ATTEMPTS=20
          ATTEMPT=1

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Tentativa $ATTEMPT de $MAX_ATTEMPTS..."

            # Verificar se os ALBs t√™m hostnames
            AUTOATENDIMENTO_ALB=$(kubectl get ingress autoatendimento-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            PAGAMENTO_ALB=$(kubectl get ingress pagamento-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")

            if [[ -n "$AUTOATENDIMENTO_ALB" && -n "$PAGAMENTO_ALB" ]]; then
              echo "‚úÖ ALBs provisionados com sucesso!"
              echo "autoatendimento_alb=$AUTOATENDIMENTO_ALB" >> $GITHUB_OUTPUT
              echo "pagamento_alb=$PAGAMENTO_ALB" >> $GITHUB_OUTPUT
              echo "Autoatendimento ALB: $AUTOATENDIMENTO_ALB"
              echo "Pagamento ALB: $PAGAMENTO_ALB"
              break
            fi

            echo "Aguardando... ALBs ainda n√£o prontos"
            kubectl get ingress
            sleep 30
            ATTEMPT=$((ATTEMPT + 1))
          done

          if [[ -z "$AUTOATENDIMENTO_ALB" || -z "$PAGAMENTO_ALB" ]]; then
            echo "‚ùå ALBs n√£o ficaram prontos no tempo esperado"
            echo "autoatendimento_alb=" >> $GITHUB_OUTPUT
            echo "pagamento_alb=" >> $GITHUB_OUTPUT
          fi

      # Smoke Tests com ALBs reais
      - name: "üß™ Smoke Test - Health Check via ALB"
        run: |
          echo "Verificando health dos servi√ßos via ALB..."

          AUTOATENDIMENTO_ALB="${{ steps.alb_wait.outputs.autoatendimento_alb }}"
          PAGAMENTO_ALB="${{ steps.alb_wait.outputs.pagamento_alb }}"

          if [[ -n "$AUTOATENDIMENTO_ALB" ]]; then
            echo "Testando Autoatendimento via ALB..."
            HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://${AUTOATENDIMENTO_ALB}/actuator/health || echo "000")
            if [[ "$HEALTH_RESPONSE" == "200" ]]; then
              echo "‚úÖ Autoatendimento health check OK via ALB"
            else
              echo "‚ö†Ô∏è Autoatendimento health check retornou: $HEALTH_RESPONSE"
            fi
          else
            echo "‚ö†Ô∏è ALB do Autoatendimento n√£o dispon√≠vel"
          fi

          if [[ -n "$PAGAMENTO_ALB" ]]; then
            echo "Testando Pagamento via ALB..."
            HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://${PAGAMENTO_ALB}/actuator/health || echo "000")
            if [[ "$HEALTH_RESPONSE" == "200" ]]; then
              echo "‚úÖ Pagamento health check OK via ALB"
            else
              echo "‚ö†Ô∏è Pagamento health check retornou: $HEALTH_RESPONSE"
            fi
          else
            echo "‚ö†Ô∏è ALB do Pagamento n√£o dispon√≠vel"
          fi

      - name: "üß™ E2E Test - Cliente An√¥nimo"
        id: e2e_test
        run: |
          echo "Executando teste E2E com cliente an√¥nimo..."
          API_URL="${{ steps.get_config.outputs.api_gateway_url }}"

          # 1. Obter token an√¥nimo
          echo "Obtendo token para cliente an√¥nimo..."
          AUTH_RESPONSE=$(curl -s -X POST ${API_URL}/v1/auth/identificar \
            -H "Content-Type: application/json" \
            -d '{"cpf": null}')

          TOKEN=$(echo $AUTH_RESPONSE | jq -r '.token' || echo "")

          if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then
            echo "‚ùå Falha ao obter token de autentica√ß√£o"
            echo "Response: $AUTH_RESPONSE"
            echo "e2e_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "‚úÖ Token obtido com sucesso"

          # 2. Criar um pedido
          echo "Criando pedido de teste..."
          PEDIDO_RESPONSE=$(curl -s -X POST ${API_URL}/v1/autoatendimento/pedidos/checkout \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "cpfCliente": null,
              "itens": [
                {
                  "produtoId": 1,
                  "quantidade": 1,
                  "observacao": "Teste E2E Pipeline"
                }
              ]
            }')

          PEDIDO_ID=$(echo $PEDIDO_RESPONSE | jq -r '.id' || echo "")

          if [[ -n "$PEDIDO_ID" && "$PEDIDO_ID" != "null" ]]; then
            echo "‚úÖ Pedido criado com sucesso! ID: $PEDIDO_ID"
            echo "e2e_success=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Falha ao criar pedido - integra√ß√£o quebrada"
            echo "Response: $PEDIDO_RESPONSE"
            echo "e2e_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: "üìä Resumo do Pipeline"
        if: always()
        run: |
          echo "=== RESUMO DO PIPELINE APPLICATION ==="
          echo "‚úÖ Unit Tests: Executados com sucesso"
          echo "‚úÖ Build Maven: Aplica√ß√µes compiladas"
          echo "‚úÖ Docker Images: Constru√≠das e enviadas ao ECR"
          echo "‚úÖ Kubernetes Deploy: Aplica√ß√µes implantadas"
          echo "‚úÖ ALBs: Provisionados e configurados"
          if [[ "${{ steps.e2e_test.outputs.e2e_success }}" == "true" ]]; then
            echo "‚úÖ Teste E2E: Stack completa validada com sucesso"
          else
            echo "‚ùå Teste E2E: Falha na valida√ß√£o - verificar logs acima"
            echo "Isso indica problema na integra√ß√£o entre componentes"
          fi
          echo "======================================="
          echo ""
          if [[ "${{ steps.e2e_test.outputs.e2e_success }}" == "true" ]]; then
            echo "üéâ IMPLANTA√á√ÉO COMPLETA E VALIDADA!"
          else
            echo "‚ö†Ô∏è IMPLANTA√á√ÉO COM PROBLEMAS - REVISAR LOGS"
          fi
          echo "API Gateway URL: ${{ steps.get_config.outputs.api_gateway_url }}"
          AUTOATENDIMENTO_ALB="${{ steps.alb_wait.outputs.autoatendimento_alb }}"
          PAGAMENTO_ALB="${{ steps.alb_wait.outputs.pagamento_alb }}"
          if [[ -n "$AUTOATENDIMENTO_ALB" ]]; then
            echo "Autoatendimento ALB: http://$AUTOATENDIMENTO_ALB"
          fi
          if [[ -n "$PAGAMENTO_ALB" ]]; then
            echo "Pagamento ALB: http://$PAGAMENTO_ALB"
          fi