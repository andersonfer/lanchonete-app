name: Deploy App Autoatendimento

on:
  workflow_dispatch:  # Permite execu√ß√£o manual em qualquer branch
  push:
    branches:
      - main
      - feature/**  # Permite teste em branches feature
      - develop     # Se houver branch develop
    paths:
      - 'app/autoatendimento/**'
      - 'k8s_manifests/autoatendimento/**'
      - '.github/workflows/app-autoatendimento.yml'

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: lanchonete-autoatendimento
  SERVICE_NAME: autoatendimento

jobs:
  build-and-deploy:
    name: Build e Deploy Autoatendimento
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout c√≥digo
      uses: actions/checkout@v3

    - name: Configurar AWS CLI
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-region: ${{ env.AWS_REGION }}
        # LabRole deve ser configurado atrav√©s de secrets ou OIDC

    - name: Login no Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Setup Java
      uses: actions/setup-java@v3
      with:
        distribution: 'temurin'
        java-version: '17'
        cache: 'maven'

    - name: Build da aplica√ß√£o
      working-directory: app/autoatendimento
      run: mvn clean package -DskipTests

    - name: Build e push da imagem Docker
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG app/autoatendimento
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

    - name: Baixar outputs do RDS
      uses: actions/download-artifact@v3
      with:
        name: rds-outputs
        path: .
      continue-on-error: false  # Falha se n√£o encontrar o artefato

    - name: Criar Secret Kubernetes com credenciais RDS
      run: |
        set -e
        set -o pipefail
        
        # Valida que o arquivo existe
        if [ ! -f rds-outputs.json ]; then
          echo "‚ùå Arquivo rds-outputs.json n√£o encontrado. Execute o pipeline infra-rds primeiro."
          exit 1
        fi
        
        # L√™ outputs do RDS
        echo "üìã Lendo credenciais do RDS..."
        RDS_ADDRESS=$(jq -r '.rds_address.value' rds-outputs.json)
        RDS_DATABASE=$(jq -r '.database_name.value' rds-outputs.json)
        RDS_USERNAME=$(jq -r '.database_username.value' rds-outputs.json)
        RDS_PASSWORD=$(jq -r '.database_password.value' rds-outputs.json)
        
        # Valida que todos os valores foram obtidos
        if [ -z "$RDS_ADDRESS" ] || [ -z "$RDS_DATABASE" ] || [ -z "$RDS_USERNAME" ] || [ -z "$RDS_PASSWORD" ]; then
          echo "‚ùå Erro ao ler outputs do RDS. Valores faltando."
          echo "RDS_ADDRESS: $RDS_ADDRESS"
          echo "RDS_DATABASE: $RDS_DATABASE"
          echo "RDS_USERNAME: $RDS_USERNAME"
          echo "RDS_PASSWORD: [HIDDEN]"
          exit 1
        fi
        
        # Monta a URL JDBC
        JDBC_URL="jdbc:mysql://${RDS_ADDRESS}:3306/${RDS_DATABASE}"
        echo "‚úÖ URL JDBC montada: ${JDBC_URL}"
        
        # Configura kubeconfig
        echo "üîß Configurando acesso ao cluster EKS..."
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name lanchonete-cluster
        
        # Cria ou atualiza o Secret
        echo "üîê Criando/atualizando Secret Kubernetes..."
        kubectl create secret generic rds-secret \
          --from-literal=SPRING_DATASOURCE_URL="${JDBC_URL}" \
          --from-literal=SPRING_DATASOURCE_USERNAME="${RDS_USERNAME}" \
          --from-literal=SPRING_DATASOURCE_PASSWORD="${RDS_PASSWORD}" \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # Verifica se o Secret foi criado
        kubectl get secret rds-secret -o jsonpath='{.metadata.name}' > /dev/null
        if [ $? -eq 0 ]; then
          echo "‚úÖ Secret 'rds-secret' criado/atualizado com sucesso"
        else
          echo "‚ùå Falha ao criar Secret"
          exit 1
        fi

    - name: Deploy no Kubernetes
      env:
        IMAGE_TAG: ${{ github.sha }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        set -e
        set -o pipefail
        
        # Configura kubeconfig (j√° foi configurado no step anterior, mas garantindo)
        echo "üîß Configurando acesso ao cluster EKS..."
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name lanchonete-cluster
        
        # Verifica se o Secret existe antes de fazer deploy
        echo "üîç Verificando se o Secret RDS existe..."
        kubectl get secret rds-secret > /dev/null
        if [ $? -ne 0 ]; then
          echo "‚ùå Secret 'rds-secret' n√£o encontrado. Execute o step anterior."
          exit 1
        fi
        echo "‚úÖ Secret encontrado"
        
        # Aplica todos os manifests (exceto o secret placeholder que j√° foi criado)
        echo "üì¶ Aplicando manifests do Kubernetes..."
        for manifest in k8s_manifests/autoatendimento/*.yaml; do
          if [[ ! "$manifest" == *"rds-secret.yaml"* ]]; then
            echo "  Aplicando: $(basename $manifest)"
            kubectl apply -f "$manifest"
          fi
        done
        
        # Atualiza a imagem no deployment
        echo "üê≥ Atualizando imagem Docker no deployment..."
        kubectl set image deployment/autoatendimento-deployment \
          app=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
          -n default
        
        # Verifica se os pods est√£o recebendo as vari√°veis de ambiente
        echo "üîç Verificando vari√°veis de ambiente nos pods..."
        sleep 5  # Aguarda um pouco para o pod come√ßar a ser criado
        
        # Aguarda o deployment ficar pronto
        echo "‚è≥ Aguardando deployment ficar pronto..."
        kubectl rollout status deployment/autoatendimento-deployment -n default --timeout=5m
        
        # Valida que o pod tem as vari√°veis de ambiente configuradas
        echo "‚úÖ Validando configura√ß√£o do pod..."
        POD_NAME=$(kubectl get pods -l app=autoatendimento -n default -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
        if [ -n "$POD_NAME" ]; then
          echo "  Pod encontrado: $POD_NAME"
          # Verifica se as vari√°veis existem (sem mostrar os valores)
          kubectl exec $POD_NAME -n default -- printenv | grep -q SPRING_DATASOURCE_URL
          if [ $? -eq 0 ]; then
            echo "‚úÖ Vari√°veis de ambiente do banco de dados configuradas corretamente"
          else
            echo "‚ö†Ô∏è Aviso: N√£o foi poss√≠vel confirmar as vari√°veis de ambiente"
          fi
        fi
        
        echo "üéâ Deploy conclu√≠do com sucesso!"